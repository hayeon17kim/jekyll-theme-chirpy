<!DOCTYPE html><html lang="kr-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스" /><meta name="author" content="hayeon_kim" /><meta property="og:locale" content="kr_KR" /><meta name="description" content="mini pms v22 - 상속" /><meta property="og:description" content="mini pms v22 - 상속" /><link rel="canonical" href="https://hayeon17kim.github.io//posts/200903-32/" /><meta property="og:url" content="https://hayeon17kim.github.io//posts/200903-32/" /><meta property="og:site_name" content="하연" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-09-03T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스" /><meta name="twitter:site" content="@MONI56219559" /><meta name="twitter:creator" content="@hayeon_kim" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"hayeon_kim"},"headline":"학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스","dateModified":"2020-09-03T00:00:00+08:00","datePublished":"2020-09-03T00:00:00+08:00","description":"mini pms v22 - 상속","url":"https://hayeon17kim.github.io//posts/200903-32/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hayeon17kim.github.io//posts/200903-32/"},"@context":"https://schema.org"}</script><title>학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스 | 하연</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-173202420-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-173202420-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/bio-photo.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">하연</a></div><div class="site-subtitle font-italic">어제보다 나은 코드를 위해</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-laptop-code ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/hayeon17kim" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/MONI56219559" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hayeon17kim','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Sep 3, 2020, 12:00 AM +0800" > Sep 3, 2020 <i class="unloaded">2020-09-03T00:00:00+08:00</i> </span> by <span class="author"> hayeon_kim </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7320 words">40 min</span></div></div><div class="post-content"><h1 id="mini-pms-v22---상속">mini pms v22 - 상속</h1><h2 id="상속-구현-방법">상속 구현 방법</h2><p><strong>상속(inheritance)</strong> 을 구현하는 방법에는 <strong>전문화</strong>와 <strong>일반화</strong> 두 가지가 있다.</p><h3 id="1-전문화">1. 전문화</h3><ul><li>기존 클래스의 기능을 그대로 활용할 수 있도록 <strong>연결</strong>하고, 여기에 새 기능을 추가하거나 기존 기능을 변경하여 좀 더 특수 목적의 서브 클래스를 만드는 기법이다.<li>마치 부모로부터 무언가를 물려 받는 것과 같아 상속 이라는 문법의 대표적인 기법으로 알려져 있다. 그래서 객체지향 프로그래밍의 상속을 얘기할 때는 대부분 <strong>전문화</strong> 를 가르킨다.</ul><h3 id="2-일반화">2. 일반화</h3><ul><li>클래스들의 공통 분모를 추출하여 수퍼 클래스를 정의하는 기법이다.<li>새로 정의한 수퍼 클래스와 부모/자식 관계를 맺는다.<li>프로그래밍 처음부터 상속을 고려하여 수퍼 클래스를 정의하는 것이 아니라 <strong>코드를 리팩토링하는 과정</strong>에서 수퍼 클래스를 정의하는 것이기 때문에 초보 개발자에게 적합하다.<li>보통 일반화를 통해 추출된 수퍼 클래스는 서브 클래스에게 공통 분모를 상속해주는 것이 목적이다. 직접 인스턴스를 생성하고 사용하기 위해 만든 클래스가 아니다. 그래서 일반화를 통해 도출한 수퍼 클래스는 보통 <strong>추상 클래스</strong>로 정의한다.</ul><h2 id="실습-목표">실습 목표</h2><ul><li>상속의 기법에서 <strong>전문화</strong> 와 <strong>일반화</strong> 기법을 이해하고 구현하는 방법을 배운다.<li><strong>추상 클래스</strong> 의 용도를 이해하고 활용법을 연습한다.<li><strong>다형적 변수(ploymorphic variables)</strong> 를 이용하여 서브 클래스의 인스턴스를 다루는 것을 연습한다.<li><strong>의존성 주입(dependency injection; DI)</strong> 의 의미를 이해한다.</ul><h2 id="실습-내용">실습 내용</h2><ul><li><code class="language-plaintext highlighter-rouge">ArrayList</code>, <code class="language-plaintext highlighter-rouge">LinkedList</code> 의 공통 분모를 추출하여 수퍼 클래스를 정의한다.<li>XxxHandler 에서 사용할 List 객체를 외부에서 주입 받는 방식으로 변경한다.</ul><h2 id="일반화-수퍼클래스-정의">일반화: 수퍼클래스 정의</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.eomcs.util</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">protected</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
  <span class="o">}</span>
    
    <span class="c1">// 아래 메서드들은</span>
    <span class="c1">// ArrayList나 LinkedList에서 동작 방법이 다르기 때문에</span>
    <span class="c1">// 여기서 구현할 필요가 없다.</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 서브 클래스에서 메서드를 구현하는 방법이 다르기 때문에</span>
    <span class="c1">// 수퍼 클래스에서는 구현하지 않고 오버라이딩하게 한다.</span>

    <span class="c1">// 수퍼 클래스에서 실질적으로 구현하지 않는 이 메서드를 두는 이유</span>
    <span class="c1">// =&gt; 서브 클래스들이 갖춰야 할 기능을 정의</span>
    <span class="c1">// =&gt; 즉 서브 클래스들에게 반드시 갖춰야 할 기능을 강제</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
  

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">)</span> <span class="o">{}</span>

  <span class="kd">public</span> <span class="no">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="no">E</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="no">E</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="no">E</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="no">E</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>일반화는 상속 구현 방법의 일종으로, 서브 클래스의 공통 분모를 추출하여 수퍼 클래스로 정의 하고 상속 관계를 맺는 기법이다. 이전 버전에서 구현한 ArrayList와 LinkedList의 메서드들의 시그니처와 변수는 변수명은 모두 같다. 따라서 두 클래스의 공통분모인 변수와 메서드를 추출하여 수퍼 클래스로 정의하고 상속 관계를 맺어주었다. 이렇게 상속 관계를 맺을 경우 다형성을 이용하여 서브객체의 교체가 쉬워진다.</p><blockquote><p>상속에 대한 오해! 서브 클래스는 수퍼 클래스의 코드를 그대로 가져오는 것이 아니다. 다만 연결될 뿐이다. 컴파일 하면 그 바이트 코드에는 해당 클래스에 대한 것만 있다.</p></blockquote><p>기존 ArrayList와 LinkedList는 List를 상속받게 하였으며 각 메서드를 오버라이딩하도록 하였다.</p><h2 id="다형적-변수-수퍼클래스의-레퍼런스로-선언">다형적 변수: 수퍼클래스의 레퍼런스로 선언</h2><p>수퍼 클래스는 다형적 변수로 사용할 수 있다. 서브클래스의 인스턴스를 다룰 수 있다. Handler에서 사용할 목록 관리 객체를 <strong>수퍼 클래스의 레퍼런스로 선언</strong>해, 수퍼클래스(List)의 서브 객체(ArrayList, LinkedList)로 <strong>교체하기 쉽도록</strong> 만든다. 즉 다형적 변수의 특징을 이용해서 <code class="language-plaintext highlighter-rouge">ArrayList</code> 또는 <code class="language-plaintext highlighter-rouge">LinkedList</code> 객체를 모두 담을 수 있도록 <code class="language-plaintext highlighter-rouge">list</code> 타입의 필드로 선언한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoardHandler</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Board</span><span class="o">&gt;</span> <span class="n">boardList</span><span class="o">;</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="의존성-주입">의존성 주입</h2><p>Handler가 의존하는 객체를 내부에서 생성하지 않고 생성자를 통해 외부에서 주입받는 것을 말한다. 이를 통해서 <strong>의존 객체 교체가 쉬워진다.</strong> 생성자의 파라미터를 통해 <code class="language-plaintext highlighter-rouge">List</code> 클래스의 서브 클래스를 공급받도록 변경하였다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoardHandler</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Board</span><span class="o">&gt;</span> <span class="n">boardList</span><span class="o">;</span>
    
    <span class="c1">// 생성자의 파라미터로 List 클래스의 서브 클래스를 공급받도록 변경한다.</span>
    <span class="c1">// 외부 객체 주입을 강제한다.</span>
    <span class="kd">public</span> <span class="nf">BoardHAndler</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Board</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">boardList</span> <span class="o">=</span> <span class="n">boardList</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Handler가 사용할 List 객체 (의존 객체; dependency)를 <strong>생성자에서 직접 만들지 않고</strong>, 이렇게 생<strong>성자가 호출될 때 파라미터로 받으면</strong> 필요에 따라 List 객체를 다른 객체로 <strong>대체하기 쉽다.</strong> 즉 다형적 변수 법칙에 따라 List의 하위 객체라면 어떤 객체든지 가능하다. 이런 식으로 의존 객체를 외부에서 주입받는 것을 “Dependency Injection(DI; 의존성주입)”이라 부른다. 즉 <strong>의존객체를 부품화하여 교체하기 쉽도록 만드는 방식이다.</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Board</span><span class="o">&gt;</span> <span class="n">boardList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">BoardHandler</span> <span class="n">boardHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoardHandler</span><span class="o">(</span><span class="n">boardList</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="ioc-inversion-of-control-제어의-역전">IOC (Inversion of Control: 제어의 역전)</h2><ul><li>보통 계획에 따라 작업을 하는데 예상하지 못하게 제어하는 경우가 있다.<li><p>이 중 하나가 Dependency Injection 이다.</p><li><p>컨테이너란? 작성한 코드의 처리과정을 위임받은 독립적인 존재이다. 적절한 설정만 있으면 누구의 도움 없이도 프로그래머가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다. 프로그래머가 작성한 코드는 컨테이너를 사용하게 됨으로서 프로그래머의 손을 떠나 컨테이너의 영역으로 떠나버리게 된다. 정확하게 이야기하면 컨테이너가 마음대로 객체를 생성하는 것이 아니라 프로그램을 이용하는 이용자의 호출에 의해 컨테이너가 동작하게 되는 구조이다. 컨테이너의 예로는 스프링과 톰캣(WAS) 이 있다. 작성한 서블릿을 쓸 지 말 지는 톰캣이 결정한다. 즉 작성한 코드가 언제 호출될 지 감도 안 오는 막막한 상태라면 올바르게 컨테이너를 이용하고 있는 것이다.</p><li><p>IOC란? 컨테이너다. 한글로 번역하자면 제어의 역전이다. 컨테이너는 작성한 코드 컨트롤(객체의 생성과 소멸)을 대신 해주는데 이 IOC 덕분에 언제 호출될지도 모르는 코드를 마음껏 칠 수 있게 되었다.</p><li><p>DI란? IOC의 일종이다. 받아먹기도 전에 미리 받아먹겠다고 선언하는 주는 놈은 생각도 않았는데 먼저 말부터 꺼내놓는 파렴치한 코딩방식 (ㅋㅋㅋ)이라고 할 수 있다. DI란 전략페턴을 일종의 프레임워크처럼 편리하게 사용할 수 있도록 만든 것이라고 할 수 있다. 스프링은 이런 전략 패턴을 편리화하였다. DI 방식으로 코드를 작성한다면 현재 사용하고 있는 객체의 메서드가 어떻게 작성되었는지 알 필요가 없으며 그 클래스가 기능을 잘 구현했는지 조차도 알 필요가 없다. 그저 클래스의 기능을 추상적으로 묶어둔 인터페이스만 갖다 쓰면 그만이다. 나머지는 스프링에서 찜한 걸 연결시켜주니 말이다.</p><li>인터페이스의 메서드만 이용하더라도 구현부는 나중에 주입을 통해 해결하므로 획기적인 분업과 동시에 구현 클래스를 쉽게 교체할 수 있다는 장점을 얻게 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">StrategyPattern</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">dependency_injection</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">StrategyPatternImpl</span> <span class="kd">implements</span> <span class="nc">StrategyPattern</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dependency_injection</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"줄 놈은 생각도 안했던 그 메서드"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">StrategyPatternService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StrategyPattern</span> <span class="n">sp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StrategyPatternImpl</span><span class="o">();</span>
        <span class="n">sp</span><span class="o">.</span><span class="na">dependency_injection</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 결과</span>
<span class="c1">// 줄 놈은 생각도 안 했던 그 메서드</span>
</pre></table></code></div></div><h1 id="23---추상-클래스와-추상-메서드">23 - 추상 클래스와 추상 메서드</h1><h2 id="추상-클래스">추상 클래스</h2><ul><li>서브 클래스에 기본 기능 및 공통 분모를 상속해 주는 역할을 하는 클래스<li>new 명령을 통해 인스턴스를 생성할 수 없다.<li><strong>상속</strong> 의 기법 중에서 <strong>일반화</strong> 를 통해 수퍼 클래스를 정의한 경우 보통 추상 클래스로 선언한다.<li>추상 메서드를 가질 수 있다.<li>일반 클래스, 콘크리트 클래스(concrete class)는 이러한 추상 클래스와 반대 개념이다.<li>일반화를 할 때 보통 추상 클래스를 선언한다.</ul><h2 id="추상-메서드">추상 메서드</h2><ul><li><strong>서브 클래스에 따라 구현 방법이 다른 경우</strong> 보통 추상 메서드로 선언한다.<li>서브 클래스에서 <strong>반드시 구현</strong>해야 하는 메서드다. 따라서 서브 클래스를 정의할 때 반드시 해당 메서드를 <strong>구현하도록 강제</strong>하고 싶다면 추상 메서드로 선언한다.<li>일반 클래스는 추상 메서드를 가질 수 없다.<li>추상 클래스와 인터페이스 만이 추상 메서드를 가질 수 있다.</ul><h2 id="실습-목표-1">실습 목표</h2><ul><li><strong>추상 클래스</strong> 의 용도를 이해하고 활용법을 연습한다.<li><strong>추상 메서드</strong> 의 용도와 활용법을 연습한다.</ul><h2 id="실습-내용-1">실습 내용</h2><ul><li><code class="language-plaintext highlighter-rouge">List</code> 클래스를 추상 클래스로 변경한다.<li><code class="language-plaintext highlighter-rouge">List</code> 클래스의 메서드를 추상 메서드로 변경한다.</ul><h2 id="추상-클래스-및-추상-메서드-선언">추상 클래스 및 추상 메서드 선언</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 서브 클래스가 직접 인스턴스 필드를 사용할 수 있도록 하기 위해</span>
    <span class="c1">// 접근 범위를 protected 로 선언한다.</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    
    <span class="c1">// 수퍼 클래스에서 구현해도 상관 없는 메서드는 일반 메서드로 구현한다.</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 서브 클래스에서 정의할 메서드라면 수퍼 클래스에서 정의하지 않고</span>
    <span class="c1">// 서브 클래스가 반드시 구현하도록 강제한다.</span>
    <span class="c1">// =&gt; 메서드 선언부에 abstract 키워드(modifier)를 붙인다.</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">value</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="no">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="no">E</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">e</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="no">E</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="no">E</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="no">E</span><span class="o">[]</span> <span class="n">arr</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>추상 클래스 문법의 목적: 추상 클래스는 인스턴스 생성 목적의 클래스가 아니라 공통점을 뽑아내는 용도이다. 따라서 추상 클래스 문법은 서브 클래스에게 <strong>공통 분모(멤버)를 물려주는 용도</strong>의 클래스를 <strong>직접 인스턴스를 생성하지 못하도록</strong> 막는다.<ul><li>보통 추상클래스는 AbstractXxxx 형식으로 짓는다.</ul><li>추상 메서드 문법의 목적: 서브클래스에서 해당 메서드를 <strong>오버라이딩하도록 강제</strong>한다.<ul><li>서브 클래스가 반드시 재정의해야 할 메서드라면 수퍼 클래스에서 정의하지 않는다.</ul></ul><h1 id="상속">상속</h1><h2 id="상속의-종류">상속의 종류</h2><h3 id="specialization">specialization</h3><ul><li>가장 많이 사용하는 방법으로 수퍼 클래스를 상속 받아 서브 클래스를 만드는 것이다. 수퍼클래스에 새 특징을 추가하거나 새 기능을 추가하여 더 특별한 일을 수행하는 서브클래스를 만든다.<li>그래서 이런 상속을 “특수화/전문화(specialization)”이라 부른다.</ul><h3 id="generalization">generalization</h3><ul><li>리팩토링 과정에 수행하는 방법이다.<li>서브클래스들의 공통 분모를 추출하여 수퍼클래스를 정의하는 방법을 말한다. 그래서 이런 상속을 “일반화/표준화(generalization)”이라 부른다.</ul><h2 id="추상-클래스-1">추상 클래스</h2><p>서브 클래스에 변수와 메서드를 상속해주는 용도로 사용한다. 인스턴스를 생성해 직접 사용할 수 없다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{}</span>
</pre></table></code></div></div><h2 id="추상-메서드-1">추상 메서드</h2><p>수퍼 클래스에서 정의하지 않고 서브 클래스에 반드시 정의하도록 강제하는 문법이 추상 메서드이다.추상 메서드는 구현할 수 없다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">m1</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="추상-클래스와-추상-메서드">추상 클래스와 추상 메서드</h2><p>추상 메서드는 구현하지 않은 메서드이기 때문에 일반 클래스 (= 구현 클래스; concrete class)는 추상 메서드를 가질 수 없다. 오직 추상 클래스만이 추상 메서드를 가질 수 있다.</p><p>일반 클래스는 인스턴스를 생성할 수 있고, 인스턴스로 메서드를 호출한다. 그런데 만약 클래스가 구현하지 않은 메서드를 가지고 있다면 호출할 때 오류가 발생할 것이다. 원천적으로 이런 문제를 발생시키지 않게 하기 위해 일반 클래스는 추상 메서드를 갖지 않게 하였다.</p><p>추상 클래스의 용도는 서브 클래스들이 가져야 할 공통 변수나 메서드를 제공하는 것이다. 따라서 일반 변수나 메서드, 특히 추상 메서드를 가질 수 있다.</p><p>특별히 추상 메서드를 선언하는 경우는</p><ul><li><p>첫째, 서브 클래스마다 구현이 달라 굳이 수퍼 클래스에서 정의할 필요가 없을 때이다.</p><li>둘째, 서브 클래스에게 메서드 오버라이딩을 강제해야 할 때이다.<ul><li>서브 클래스가 상속 받은 추상 클래스를 구현하지 않는다면 추상 메서드를 그냥 보유하기 때문에 일반 클래스가 될 수 없다. 추상 클래스가 되어야 한다. (따라서 이 경우 <code class="language-plaintext highlighter-rouge">abstract </code> 키워드를 빼먹을 경우 컴파일러 오류를 발생시킨다.)</ul><li>직접 인스턴스를 만들어 사용하기 위해 정의한 클래스가 아니라 서브 클래스에게 공통 기능을 상속해주는 목적으로 만든 클래스인 경우 추상클래스로 선언해 클래스 사용을 막자.<li>보통 일반화 과정에서 생성되는 클래스를 추상 클래스로 만든다.</ul><h2 id="디자인-패턴과-추상-클래스---템플릿-메서드-패턴">디자인 패턴과 추상 클래스 - 템플릿 메서드 패턴</h2><p>템플릿 메서드 패턴은 수퍼 클래스에서 추상적으로 표현하고, 서브 클래스에서 그 구체적인 내용을 결정하는 설계 방식을 말한다. 즉 수퍼 클래스에서 전체적인 논리 흐름을 정의하고, 서브 클래스에서 각 흐름에 따라 구체적인 동작을 정의한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Building</span> <span class="o">{</span>
    <span class="c1">// 일반 메서드: 전체적인 논리 흐름 정의</span>
    <span class="c1">// 서브 클래스는 메서드를 그대로 상속받기 때문에</span>
    <span class="c1">// 모든 서브 클래스들이 건물을 지을 때 동일한 방식으로 작업할 것이다.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">build</span> <span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"건축하겠습니다!"</span><span class="o">);</span>
        <span class="n">startEffect</span><span class="o">();</span>
        
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"건축이 완료되었습니다!"</span><span class="o">);</span>
        <span class="n">endEffect</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 템플릿 메서드: 틀만 갖춘 상태</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">startEffect</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">endEffect</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Farm</span> <span class="kd">extends</span> <span class="nc">Building</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startEffect</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"땅을 고른다."</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endEffect</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"씨앗을 뿌린다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Restaurant</span> <span class="kd">extends</span> <span class="nc">Building</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startEffect</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"뚝딱뚝딱"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endEffect</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"밥을 먹는다!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Exam01</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Restaurant</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Restaurant</span><span class="o">();</span>
        <span class="nc">Farm</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Farm</span><span class="o">();</span>
        
        <span class="n">work</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="n">work</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">(</span><span class="nc">Building</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h1 id="인터페이스">인터페이스</h1><h2 id="배경">배경</h2><h3 id="인터페이스-문법-이전">인터페이스 문법 이전</h3><p>인터페이스 문법을 사용하기 전 코드를 보자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlueWorker</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFight</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"육체 노동자가 일을 합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JubuWorker</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSsingSsing</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"주부로 일합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WhiteWorker</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doZingZing</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"사무직 노동자가 일을 합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>객체 사용</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Exam01</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BlueWorker</span> <span class="n">w1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BlueWorker</span><span class="o">();</span>
        <span class="nc">JubuWorker</span> <span class="n">w2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JubuWorker</span><span class="o">();</span>
        <span class="nc">WhiteWorker</span> <span class="n">w3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WhiteWorker</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 메서드 호출 방법이 다르기 때문에 </span>
    <span class="c1">// 각 노동자에게 일을 시키는 방법이 다르다.</span>
    <span class="n">w1</span><span class="o">.</span><span class="na">doFight</span><span class="o">();</span>
    <span class="n">w2</span><span class="o">.</span><span class="na">doZingZing</span><span class="o">();</span>
    <span class="n">w3</span><span class="o">.</span><span class="na">doSsingSsing</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>객체에 일을 시키는 방식은 비슷한데 <strong>메서드 시그니처가 다르기 때문에</strong> 호출 시 <strong>일관성이 없다.</strong> 즉 worker 객체를 사용하는 입장에서는 각 worker에 어떤 메서드가 있는지 확인해서 그 <strong>형식</strong>에 맞춰야 하기 때문에 <strong>객체를 사용하기가 불편</strong>하다. 또한, 앞으로 worker를 추가 제작할 경우 개발자의 입맛에 맞춰 메서드 이름과 파라미터 형식이 결정될 것이기에 더 worker 객체를 사용하기 어려워진다.</p><blockquote><p>유사한 일을 하는 데 객체 사용법이 다르면 쓰기가 매우 불편하다.</p></blockquote><p>따라서 유사한 일을 하는 객체에 대해 사용법을 통일하자. 이를 위해서는</p><ul><li>객체의 사용 규칙을 정의한다.<li>클래스를 정의할 그 규칙에 따라 만든다.<li>규칙에 따라 만든 클래스를 사용할 때는 일관된 방법으로 메서드를 호출할 수 있다.</ul><blockquote><p>이렇게 객체의 사용 규칙을 정의하는 문법이 “인터페이스”이다.</p></blockquote><h2 id="호출-규칙으로서의-인터페이스">호출 규칙으로서의 인터페이스</h2><p>인터페이스는 caller와 callee 사이의 호출 규칙을 정의하는 문법이다.</p><ul><li><p>사용 규칙: Worker</p><li><p>caller(호출자; 사용자): Exam01</p><li><p>callee(피호출차; 도구): BlueWorker, JubuWorker, WhiteWorker</p><p>호출 규칙이란? 메서드 형식을 의미한다.</p><p>메서드 몸체는 규칙에 따라 만드는 클래스에서 정의하는 것이다.</p></ul><h3 id="인터페이스-문법-이후">인터페이스 문법 이후</h3><p>위의 코드를 다음과 같이 인터페이스 문법을 사용해 변경하자.</p><p><strong>interface(호출 규칙)</strong>: Worker</p><p>=&gt; worker 객체의 사용 규칙을 정의한다</p><pre><code class="language-Java">// 인터페이스 - caller와 callee 사이의 호출 규칙을 정의하는 문법
public interface Worker {
    void execute();
}
</code></pre><p><strong>callee(피호출차; 도구):</strong> BlueWorker, JubuWorker, WhiteWorker</p><p>=&gt; 클래스를 정의할 때 Worker 규칙에 따라 만든다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Worker 인터페이스를 이행하는 클래스: Worker "구현체"</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlueWorker</span> <span class="kd">implements</span> <span class="nc">Worker</span> <span class="o">{</span>
    <span class="c1">// 인터페이스 구현체(인터페이스를 구현하는 클래스)는 </span>
    <span class="c1">// 반드시 인터페이스에 선언된 모든 메서드를 구현해야 한다.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"육체 노동자가 일을 합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JubuWorker</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSsingSsing</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"주부로 일합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WhiteWorker</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doZingZing</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"사무직 노동자가 일을 합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>caller(호출자; 사용자):</strong> Exam01</p><p>=&gt; worker를 사용하는 측에서는 Worker 인터페이스에 정의된 대로 메서드를 호출한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 인터페이스 레퍼런스</span>
    <span class="c1">// =&gt; 인터페이스를 구현한 클래스의 객체 주소를 저장하는 변수</span>
    <span class="nc">Worker</span> <span class="n">w1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BlueWorker</span><span class="o">();</span>
    <span class="nc">Worker</span> <span class="n">w2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WhiteWorker</span><span class="o">();</span>
    <span class="nc">Worker</span> <span class="n">w3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JubuWorker</span><span class="o">();</span>
    
    <span class="c1">// 사용하려는 객체가 같은 인터페이스를 구현(사용규칙에 따라 작성)하였다면</span>
    <span class="c1">// 다음과 같이 동일한 사용규칙에 따라 메서드를 호출할 수 있다.</span>
    <span class="c1">// 호출의 일관성 확보</span>
    <span class="n">w1</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="n">w2</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="n">w3</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
<span class="o">}</span>

    <span class="c1">// 인터페이스 레퍼런스?</span>
    <span class="c1">// =&gt; 해당 인터페이스에 따라 작성된(사용규칙을 준수하는) 클래스의 인스턴스 주소를 저장한다.</span>
    <span class="c1">// </span>
    <span class="c1">// 위 예제에서 w 레퍼런스를말로 표현하는 방법:</span>
    <span class="c1">// =&gt; Worker 사용규칙에 따라 작성된 클래스의 인스턴스 주소를 저장하는 변수 w.</span>
    <span class="c1">// =&gt; Worker 인터페이스를 구현한 클래스의 인스턴스 주소를 저장하는 변수 w.</span>
    <span class="c1">// =&gt; Worker 구현체의 인스턴스 주소를 저장하는 변수 w.</span>
    <span class="c1">// =&gt; Worker 구현체의 객체 주소를 저장하는 변수 w.</span>
    <span class="c1">// =&gt; Worker 구현 객체를 저장하는 변수 w.</span>
    <span class="c1">// =&gt; Worker 객체를 저장하는 (변수) w.</span>
    <span class="c1">// =&gt; Worker 객체를 가리키는 (변수) w.</span>
</pre></table></code></div></div><h2 id="추상-클래스와-인터페이스">추상 클래스와 인터페이스</h2><h3 id="공통점과-차이점">공통점과 차이점</h3><h3 id="인터페이스-구현을-돕는-추상-클래스">인터페이스 구현을 돕는 추상 클래스</h3><p>추상 클래스를 이용하여 인터페이스 구현을 도와줄 수 있다. 인터페이스에 메서드가 많지만, 그 중 특정 메서드만 주로 구현한다면 개발자가 인터페이스를 구현하기 편하도록 서브 클래스에서 오버라이딩할 메서드를 제외한 나머지 메서드를 추상클래스에서 구현한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractServlet</span> <span class="kd">implements</span> <span class="nc">Servlet</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(){}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">(){}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getServlet</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getServletConfig</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>인터페이스를 구현한다는 것은 <strong>인터페이스에 선언된 모든 메서드를 구현한다</strong>는 뜻이다.<ul><li>인터페이스에 선언된 메서드를 <strong>한 개라도 빠뜨리면</strong> 추상 메서드를 갖고 있는 상태가 된다. 즉 일반 클래스가 될 수 없고, <strong>추상 클래스</strong>가 되어야 한다.</ul><li>직접 인터페이스를 구현하기보다 추상 클래스를 상속받는다.<ul><li>인터페이스를 직접 구현하면 인터페이스에 선언된 모든 메서드를 구현해야 하지만, 미리 인터페이스의 몇몇 메서드를 구현한 추상 클래스를 상속받는다면 서브 클래스는 좀 더 쉽게 인터페이스를 구현할 수 있다(추상 클래스에서 구현하지 않은 메서드만 정의하면 된다)</ul><li>즉 인터페이스 메서드가 많을 경우 일부 메서드를 미리 구현함으로써 개발자가 좀 더 쉽게 인터페이스를 구현할 수 있게 도와주는 용도로 “추상 클래스” 문법을 사용할 수 있다.</ul><p>인터페이스는 객체의 사용 규칙을 정의하는 문법이다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Exam01</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  
    <span class="nc">BlueWorker</span> <span class="n">w1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BlueWorker</span><span class="o">();</span>
    <span class="nc">WhiteWorker</span> <span class="n">w2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WhiteWorker</span><span class="o">();</span>
    <span class="nc">JubuWorker</span> <span class="n">w3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JubuWorker</span><span class="o">();</span>
    
    <span class="c1">// 각 노동자에게 일을 시키는 방법이 다르다.</span>
    <span class="c1">// 왜? </span>
    <span class="c1">// =&gt; 메서드 호출 방법이 다르기 때문에</span>
    <span class="n">w1</span><span class="o">.</span><span class="na">doFight</span><span class="o">();</span>
    <span class="n">w2</span><span class="o">.</span><span class="na">doZingZing</span><span class="o">();</span>
    <span class="n">w3</span><span class="o">.</span><span class="na">doSsingSsing</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>위의 예제에서 객체의 일을 시키는 방식은 비슷한데, 메서드 시그너처가 다르기 때문에 호출할 때 일관성이 없다. 즉 객체를 사용하는 입장에서는 어떤 메서드가 있는 지 확인해서 그 형식에 맞춰야 하기 때문에 객체를 사용하기 불편하다. 또한 다른 worker 클래스를 추가 제작할 경우 메서드 이름과 파라미터 형식이 결정될 것이기 때문에 더 worker 객체를 사용하기 힘들어진다.</p><p>즉 유사한 일을 하는데 객체의 사용법이 다르다면 쓰기가 매우 불편하다. <strong>유사한 일을 하는 객체에 대해 사용법을 통일</strong>함으로써 이를 해결할 수 있다.</p><h2 id="인터페이스-사용-방법">인터페이스 사용 방법</h2><ul><li>객체 사용 규칙을 정의한다.<li>클래스를 정의할 때 그 규칙에 따라 만든다.<li>그러면 규칙에 따라 만든 클래스를 사용할 때는 일관된 방법으로 메서드를 호출할 수 있어 코딩하기가 훨씬 편해지고, 유지보수가 쉬워진다.</ul><p>이렇게 객체의 사용 규칙을 정의하는 문법이 인터페이스이다.</p><h2 id="인터페이스와-추상클래스">인터페이스와 추상클래스</h2><p>인터페이스와 추상클래스는 엄연히 다르다.</p><ul><li>추상 클래스 = 변수 + 구현된 메서드 + 추상 메서드<li>인터페이스 = 추상 메서드<ul><li>추가적으로 구현된 default 메서드, static 메서드와 final변수가 있다. 이는 다음 시간에 배울 것이다.</ul></ul><h2 id="인터페이스-레퍼런스">인터페이스 레퍼런스</h2><ul><li>인터페이스를 구현한 클래스의 객체 주소는 다 저장할 수 있다.<li>그 객체가 누구의 자식인 지는 상관하지 않는다.</ul><h2 id="인터페이스-정의">인터페이스 정의</h2><h3 id="모든-메서드는-public이다">모든 메서드는 public이다.</h3><ul><li>인터페이스에 정의하는 메서드는 호출 규칙이다. 규칙은 공개되어야 한다. 그래서 인터페이스에 선언되는 모든 메서드는 public이다. 이것은 생략 가능하다.<li>구현체에서 메서드를 구현할 때 public 보다 공개 범위를 좁힐 수 없다. 따라서 반드시 public이어야 한다.</ul><h3 id="모든-메서드는-abstract다">모든 메서드는 abstract다.</h3><ul><li>인터페이스에 선언하는 메서드는 호출 규칙을 정의한 것이다. 규칙은 클래스가 따라야 한다.<li>모든 메서드는 몸체를 구현하지 않는다. 즉, abstract 메서드이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">m1</span><span class="o">();</span>
<span class="cm">/*public abstract*/</span> <span class="kt">void</span> <span class="nf">m2</span><span class="o">();</span>
</pre></table></code></div></div><blockquote><p>자바 8부터 인터페이스에서 default 메서드, static 메서드를 정의하는 것을 허락한다. 이는 특수한 경우로 기본은 abstract라 생각하면 된다. 다음 시간에 더 자세하게 배울 것이다.</p></blockquote><h3 id="인스턴스를-만들-수-없다">인스턴스를 만들 수 없다.</h3><ul><li>인터페이스는 규칙으로 사용되기 때문에 new명령어로 인스턴스를 생성할 수 없다.<li>인터페이스에 선언되는 모든 변수는 public으로 공개되고, static으로 클래스 변수가 된다. 또한 규칙은 변경되어선느 안 되기 때문에 모든 변수는 final로 선언한다. final변수는 선언과 동시에 특정 값으로 초기화해야 한다.<li>단 인스턴스는 static 블록을 둘 수 없다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/bitcamp/'>bitcamp</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/bitcamp/" class="post-tag no-text-decoration" >bitcamp</a> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스 - 하연&url=https://hayeon17kim.github.io//posts/200903-32/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스 - 하연&u=https://hayeon17kim.github.io//posts/200903-32/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스 - 하연&url=https://hayeon17kim.github.io//posts/200903-32/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/system-deisign-capacity-estimation/">System Design: Capacity Estimate</a><li><a href="/posts/today-i-learned-2021-04-27/">주니어 성장일기: 2021.04.27</a><li><a href="/posts/today-i-learned-2021-04-26/">주니어 성장일기: 2021.04.26</a><li><a href="/posts/fastcampus-01/">자료구조와 알고리즘이란</a><li><a href="/posts/today-i-learned-2021-04-25/">주니어 성장일기: 2021.04.25</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/bitcamp/">bitcamp</a> <a class="post-tag" href="/tags/modernjs/">modernJS</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/trouble-shooting/">trouble-shooting</a> <a class="post-tag" href="/tags/devil/">devil</a> <a class="post-tag" href="/tags/corejs/">corejs</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/this-is-java-01/"><div class="card-body"> <span class="timeago small" > Aug 23, 2020 <i class="unloaded">2020-08-23T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>:coffee: [Java] 이것이 자바다 #2: 변수와 타입</h3><div class="text-muted small"><p> 리터럴 소스코드 내에서 직접 입력된 값을 리터럴이라고 부른다. 정수 리터럴, 실수 리터럴, 문자 리터럴, 논리 리터럴이 있다. 정수 리터럴을 저장할 수 있는 타입: byte, char, short, int, long 사실 리터럴은 상수(constant)와 같은 의미이지만 프로그램에서는 상수를 “값을 한 ...</p></div></div></a></div><div class="card"> <a href="/posts/this-is-java-02/"><div class="card-body"> <span class="timeago small" > Aug 24, 2020 <i class="unloaded">2020-08-24T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>:coffee: [Java] 이것이 자바다 #3: 연산자</h3><div class="text-muted small"><p> 연산자 연산식 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것 반드시 하나의 값을 산출한다. 따라서 하나의 값이 올 수 있는 곳이면 어디든지(변수에 저장되는 값 위치, 다른 연산식의 피연산자 위치) 값 대신에 연산식을 사용할 수 있다. 연산 방향과 우선순위 프로그램에서는 연산자의 연산 방향과 연산자 간의 우선 순위가 정해져 ...</p></div></div></a></div><div class="card"> <a href="/posts/MyLinkedList/"><div class="card-body"> <span class="timeago small" > Aug 25, 2020 <i class="unloaded">2020-08-25T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>:coffee: [Java] LinkedList 구현하기</h3><div class="text-muted small"><p> MyLinkedList 만들기 1단계: LinkedList 클래스 정의 public MyLinkedList {} 2단계: 값을 담을 노드 클래스 설계 Node의 인스턴스 필드와 생성자를 정의하자. public class MyLinkedList { static class Node { Object value; ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/200902-31/" class="btn btn-outline-primary" prompt="Older"><p>학원 #31일차: 연결리스트, 스택, 큐 자료구조</p></a> <a href="/posts/textbook-0704/" class="btn btn-outline-primary" prompt="Newer"><p>:book: 자바의 정석 #7.4: 제어자</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Loading comments from <a href="https://disqus.com/">Disqus</a> ...</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//hayeon17kim-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = '학원 #32일차: 일반화, 추상 클래스와 메서드, 인터페이스'; this.page.url = 'https://hayeon17kim.github.io//posts/200903-32/'; this.page.identifier = '/posts/200903-32/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/MONI56219559">hayeon_kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/bitcamp/">bitcamp</a> <a class="post-tag" href="/tags/modernjs/">modernJS</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/trouble-shooting/">trouble shooting</a> <a class="post-tag" href="/tags/devil/">devil</a> <a class="post-tag" href="/tags/corejs/">corejs</a> <a class="post-tag" href="/tags/network/">network</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://hayeon17kim.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
