<!DOCTYPE html><html lang="kr-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="모던 자바스크립트 #6.1 재귀와 스택" /><meta name="author" content="hayeon_kim" /><meta property="og:locale" content="kr_KR" /><meta name="description" content="모던 JavaScript 튜토리얼을 따라가면서 정리합니다." /><meta property="og:description" content="모던 JavaScript 튜토리얼을 따라가면서 정리합니다." /><link rel="canonical" href="https://hayeon17kim.github.io//posts/modern-js-0601/" /><meta property="og:url" content="https://hayeon17kim.github.io//posts/modern-js-0601/" /><meta property="og:site_name" content="하연" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-02-16T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="모던 자바스크립트 #6.1 재귀와 스택" /><meta name="twitter:site" content="@MONI56219559" /><meta name="twitter:creator" content="@hayeon_kim" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"hayeon_kim"},"headline":"모던 자바스크립트 #6.1 재귀와 스택","dateModified":"2021-02-16T00:00:00+08:00","datePublished":"2021-02-16T00:00:00+08:00","description":"모던 JavaScript 튜토리얼을 따라가면서 정리합니다.","url":"https://hayeon17kim.github.io//posts/modern-js-0601/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hayeon17kim.github.io//posts/modern-js-0601/"},"@context":"https://schema.org"}</script><title>모던 자바스크립트 #6.1 재귀와 스택 | 하연</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-173202420-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-173202420-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/bio-photo.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">하연</a></div><div class="site-subtitle font-italic">어제보다 나은 코드를 위해</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-laptop-code ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/hayeon17kim" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/MONI56219559" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hayeon17kim','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>모던 자바스크립트 #6.1 재귀와 스택</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>모던 자바스크립트 #6.1 재귀와 스택</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Feb 16, 2021, 12:00 AM +0800" > Feb 16 <i class="unloaded">2021-02-16T00:00:00+08:00</i> </span> by <span class="author"> hayeon_kim </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4692 words">26 min</span></div></div><div class="post-content"><p><a href="https://ko.javascript.info/">모던 JavaScript 튜토리얼</a>을 따라가면서 정리합니다.</p><h3 id="두-가지-사고방식">두 가지 사고방식</h3><p>함수 내부에서 자기 자신을 호출하는 것을 나타내는 프로그래밍 용어이다. 재귀 함수는 우아하게 원하는 문제를 해결할 때 자주 쓰인다.</p><p>x를 n제곱해 주는 함수</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">n == 1</code>: 모든 절차가 간단해진다. 명확한 결괏값을 즉시 도출하므로 이를 <strong>재귀의 베이스(base)</strong> 라고 한다. basis 라고도 불리는 재귀의 베이스(base)는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수이다.<li><code class="language-plaintext highlighter-rouge">n == 1</code>이 아닐 때: <code class="language-plaintext highlighter-rouge">pow(x, n)</code>은 <code class="language-plaintext highlighter-rouge">pow(x, n-1)</code>으로 표현될 수 있다. 수학식으론 <code class="language-plaintext highlighter-rouge">xn = x * xn-1</code>로 표현할 수 있다. 이를 <strong>재귀 단계(recursive step)</strong>이라고 한다. 여기서는 <strong>목표 작업</strong>인 <code class="language-plaintext highlighter-rouge">pow(x, n)</code>을 간단한 동작(<code class="language-plaintext highlighter-rouge">x</code>를 곱하기)과 목표 작업을 변형한 작업 <code class="language-plaintext highlighter-rouge">pow(x, n - 1)</code>으로 분할했다. 재귀 단계는 n이 1이 될 때까지 계속 이어진다.<li>중첩 호출의 최대 개수는 <strong>재귀 깊이</strong>라고 한다. <code class="language-plaintext highlighter-rouge">pow(x, n)</code> 의 재귀 깊이는 <code class="language-plaintext highlighter-rouge">n</code>이다.</ul><p>즉 <code class="language-plaintext highlighter-rouge">pow</code>는 <code class="language-plaintext highlighter-rouge">n==1</code>이 될 때까지 <em>재귀적으로</em> 자신을 호출한다.</p><p>자바스크립트 엔진은 최대 재귀 깊이를 제한한다. 만 개 정도까지는 확실히 허용하고, 엔진에 따라 더 많은 깊이를 허용하는 경우도 있다. 그러나 대다수의 엔진이 십만까지는 다루지 못한다.</p><h3 id="실행-컨텍스트와-스택">실행 컨텍스트와 스택</h3><p>실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 <strong>실행 컨텍스트(execution context)</strong>에 저장된다. 실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, <code class="language-plaintext highlighter-rouge">this</code>의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다. <strong>함수 호출 일 회당 하나의 실행 컨텍스트가 생성된다.</strong></p><p>함수 내부에 중첩 호출이 있을 때는 다음과 같은 절차가 수립된다.</p><ul><li>현재 함수의 실행이 일시 중지된다.<li>중지된 함수와 연관된 실행 컨텍스트는 실행 컨텍스트 스택(execution context stack)이라는 특별한 자료 구조에 저장된다.<li>중첩 호출이 실행된다.<li>중첩 호출 실행이 끝난 이후에 실행 컨텍스트 스택에서 일시 중지한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어간다.</ul><p>예를 들어, <code class="language-plaintext highlighter-rouge">pow(2,3)</code>을 호출하면 다음과 같이 3개의 실행 컨텍스트가 최대로 쌓일 때는 다음과 같다.</p><ul><li>Context: <code class="language-plaintext highlighter-rouge">{x: 2, n: 1, 첫번째 줄}</code> call: pow(1,2)<li>Context: <code class="language-plaintext highlighter-rouge">{x: 2, n: 2, 다섯번재 줄}</code> call: pow(2,2)<li>Context: <code class="language-plaintext highlighter-rouge">{x: 2, n: 3, 다섯번째 줄}</code> call: pow(3,2)</ul><p>재귀의 깊이는 3이다. 재귀 깊이는 스택에 들어가는 실행 컨텍스트 수의 최댓값과 같다. <strong>실행 컨텍스트는 메모리를 차지하므로 재귀를 사용할 땐 메모리 요구사항에 유의</strong>해야 한다. 이때 반복문 기반 알고리즘을 사용하면 메모리가 절약된다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">+=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>반복을 사용해 만든 함수 <code class="language-plaintext highlighter-rouge">pow</code> 는 컨텍스트를 하나만 사용한다.</strong> 이 컨텍스트에서 i와 result가 변경된다. n에 의존적이지 않고, 필요한 메모리가 적다. 사용 메모리 공가도 고정된다. <strong>모든 재귀 함수는 반복문을 사용한 함수로 다시 작성</strong>할 수 있다. <strong>최적화</strong>를 위해 반복문으로 다시 작성해야 할 수도 있다. 그러나 상당수 작업은 재귀를 사용해도 만족할 만큼 빠르게 동작한다. 재귀를 사용하면 <strong>구현과 유지보수가 쉽다</strong>는 장점이 있다.</p><h3 id="재귀적-순회recursive-traversal">재귀적 순회(recursive traversal)</h3><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">company</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">sales</span><span class="p">:</span> <span class="p">[{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">salary</span><span class="p">:</span> <span class="mi">1000</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Alice</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">salary</span><span class="p">:</span> <span class="mi">1600</span>
  <span class="p">}],</span>

  <span class="na">development</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">sites</span><span class="p">:</span> <span class="p">[{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Peter</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">salary</span><span class="p">:</span> <span class="mi">2000</span>
    <span class="p">},</span> <span class="p">{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Alex</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">salary</span><span class="p">:</span> <span class="mi">1800</span>
    <span class="p">}],</span>

    <span class="na">internals</span><span class="p">:</span> <span class="p">[{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Jack</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">salary</span><span class="p">:</span> <span class="mi">1300</span>
    <span class="p">}]</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>모든 임직원의 급여를 더한 값을 구하려면 어떻게 해야 할까? 구조가 단순하지 않기 때문에 반복문을 사용해서는 중첩의 깊이가 매우 깊어질 것이다.</p><p>임직원 급여 합계를 구할 때는 두 가지 경우로 나눠 생각할 수 있다.</p><ul><li>임직원 배열을 가진 ‘단순한’ 부서 - 간단한 반복문으로 급여 합계를 구할 수 있다. =&gt; 재귀의 베이스<li><code class="language-plaintext highlighter-rouge">N</code> 개의 하위 부서가 있는 객체 - 각 하위 부서에 속한 임직원의 급여 합계를 얻기 위해 <code class="language-plaintext highlighter-rouge">N</code> 번의 호출을 하고, 최종적으로 모든 하위부서 임직원의 급여를 더한다. =&gt; 재귀 단계</ul><p>복잡한 작업은 작은 작업(하위 부서에 대한 반복문)으로 쪼갤 수 있다. 부서의 깊이에 따라 더 작은 작업으로 쪼갤 수 있는데, 결국 마지막엔 첫 번째 경우가 된다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">sumSalaries</span><span class="p">(</span><span class="nx">department</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">Arrays</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">department</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">department</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">prev</span> <span class="o">+</span> <span class="nx">current</span><span class="p">.</span><span class="nx">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 배열의 요소를 합함</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">subdep</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">department</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">sumSalaries</span><span class="p">(</span><span class="nx">subdep</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">arr.reduce</code>는 배열의 합을 계산해 준다. 첫번재 인수( accumulator)는 앞서 호출했던 함수들의 결과가 누적되어 저장되는 누산기라고 생각하면 된다. 마지막 함수까지 호출되면 이 값은 <code class="language-plaintext highlighter-rouge">reduce</code>의 반환값이 된다. 두 번째 인수(item)은 현재 배열 요소를 뜻한다.</p></blockquote><blockquote><p><code class="language-plaintext highlighter-rouge">department.reduce((prev, current) =&gt; prev + current.salary, 0)</code></p><ol><li>함수 최초 호출 시, reduce의 마지막 인수인 0(초기값)이 <code class="language-plaintext highlighter-rouge">prev</code>에 할당된다. <code class="language-plaintext highlighter-rouge">current</code>엔 배열의 첫 번째 요소가 할당된다.<li>두 번재 호출 시, <code class="language-plaintext highlighter-rouge">prev</code>에 두 번째 요소가 더해진다.<li>세 번째 호출 시, <code class="language-plaintext highlighter-rouge">prev</code>에 세 번째 요소가 더해진다.</ol></blockquote><blockquote><p><code class="language-plaintext highlighter-rouge">for(val of Object.values(obj))</code>에서 쓰인 <code class="language-plaintext highlighter-rouge">Object.values</code>는 프로퍼티의 값이 담긴 배열을 반환한다.</p></blockquote><h3 id="재귀적-구조">재귀적 구조</h3><p>재귀적으로 정의된 자료구조는 자기 자신을 이용해 자료 구조를 정의한다.</p><p>회사 구조도 재귀적 자료 구조이다. 회사의 부서 객체는 두 가지 종류로 나뉜다.</p><ul><li>사람으로 구성된 배열<li>하위 부서로 이루어진 객체</ul><p>HTML 문서의 HTML 요소 트리나 부서를 나타내는 트리 역시 재귀적인 자료 구조로 만들었다. HTML문서에서 HTML 태그는 다음과 같은 항목으로 구성되기 때문이다.</p><ul><li>일반 텍스트<li>HTML-주석<li>이 외의 HTML 태그 (이 아래에 일반 텍스트, HTML-주석, 다른 HTML 태그가 올 수 있다)</ul><p>이렇게 재귀적인 자료구조를 사용하면 가지가 여러 개인데 각 가지가 여러 가지로 뻗쳐 나가는 형태로 자료 구조를 만들 수 있다.</p><p>예시에서 구현한 <code class="language-plaintext highlighter-rouge">sumSalary</code> 같은 재귀 함수를 사용하면 각 분기(가지)를 순회할 수 있다.</p><p>재귀적으로 정의된 자료구조에 속하는 <strong>연결 리스트</strong>는 리스트 혹은 null을 참조하는 객체로 이루어진 데이터 구조를 사용해 정의된다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nx">list</span> <span class="o">=</span> <span class="p">{</span><span class="nx">value</span><span class="p">,</span> <span class="nx">next</span> <span class="o">-&gt;</span> <span class="nx">list</span><span class="p">};</span>
</pre></table></code></div></div><p><strong>연결 리스트</strong></p><p>배열은 삭제와 삽입에 들어가는 비용이 많다.</p><blockquote><p><code class="language-plaintext highlighter-rouge">arr.unshift(obj)</code>를 수행하려면 새로운 <code class="language-plaintext highlighter-rouge">obj</code>를 위한 공간을 만들기 위해 모든 요소의 번호를 다시 매겨야 한다. 배열이 커지면 연산 수행 시간이 더 걸린다. 요소 전체의 번호를 다시 매기지 않아도 되는 조작은 배열 끝에 하는 연산인 <code class="language-plaintext highlighter-rouge">arr.push/pop</code> 뿐이다.</p></blockquote><p>빠르게 삽입 혹은 삭제를 할 때 배열 대신 연결 리스트라는 자료구조를 사용한다. 연결 리스트의 요소는 객체 아래의 프로퍼티들을 조합해 정의할 수 있다.</p><ul><li><code class="language-plaintext highlighter-rouge">value</code><li><code class="language-plaintext highlighter-rouge">next</code>: 다음 연결 리스트 요소를 참조하는 프로퍼티. 다음 요소가 없을 때는 <code class="language-plaintext highlighter-rouge">null</code>이 된다.</ul><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">next</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">next</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="na">next</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="na">next</span><span class="p">:</span> <span class="kc">null</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>위의 코드는 다음 코드와 같다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="mi">4</span> <span class="p">};</span>
<span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</pre></table></code></div></div><p>리스트의 처음 객체를 바꾸면 리스트 맨 앞에 새로운 값을 추가할 수 있다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nx">list</span> <span class="o">=</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">"</span><span class="s2">new item</span><span class="dl">"</span><span class="p">,</span> <span class="na">next</span><span class="p">:</span> <span class="nx">list</span> <span class="p">};</span>
</pre></table></code></div></div><p>중간 요소를 제거하려면 이전 요소의 <code class="language-plaintext highlighter-rouge">next</code>를 변경해준다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</pre></table></code></div></div><p>그럼 이제 <code class="language-plaintext highlighter-rouge">value 1</code>은 체인에서 제외되고, 다른 곳에 따로 저장하지 않는다면 자동으로 메모리에서 제거된다.</p><p>연결 리스트의 단점은 인덱스만 사용해 요소에 쉽게 접근할 수 없다. <code class="language-plaintext highlighter-rouge">N</code> 번째 값을 얻기 위해서는 첫번째 항목부터 시작해 <code class="language-plaintext highlighter-rouge">N</code> 번 <code class="language-plaintext highlighter-rouge">next</code>로 이동해야 한다.</p><p>위에서 구현한 연결 리스트는 다음과 같은 기능을 더해 개선할 수 있다.</p><ul><li><strong>이전 요소를 참조</strong>하는 프로퍼티 <code class="language-plaintext highlighter-rouge">prev</code> 를 추가해 이전 요소로 쉽게 이동할 수 있다.<li><strong>리스트의 마지막 요소를 참조</strong>하는 변수 <code class="language-plaintext highlighter-rouge">trai</code>를 추가할 수 있다. <strong>리스트 마지막에 요소를 추가하거나 삭제할 때 <code class="language-plaintext highlighter-rouge">tail</code> 갱신해 줘야 한다.</strong><li>이 외에도 요구사항에 따라 구조를 변경할 수 있다.</ul><h3 id="과제">과제</h3><p><strong>1. 주어진 숫자까지의 모든 숫자 더하기</strong></p><p>숫자 <code class="language-plaintext highlighter-rouge">1 + 2 + ... + n</code>을 계산하는 함수 <code class="language-plaintext highlighter-rouge">sumTo (n)</code>을 만들어보세요.</p><ul><li><p> for 반복문 사용하기</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">sumTo</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>재귀 사용하기</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">sumTo</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">sumTo</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>등차수열 공식 사용하기</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">sumTo</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="nx">alert</span><span class="p">(</span> <span class="nx">sumTo</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">);</span>
</pre></table></code></div></div><li><p>세 가지 방법 중 어떤 방법이 가장 빠른가요? 어떤 방법이 가장 느린가요? 이유도 함께 제시해주세요.</p><p>등차수열 공식이 가장 빠르다. for 반복문과 재귀는 n번 반복된다. 즉 O(n)이다. 그러나 등차수열 공식을 사용하면 O(1)이다. 재귀를 사용하는 경우 중첩 호출과 실행 컨텍스트 스택 관리가 필요하기 때문에 더 많은 자원을 사용해서 가장 느리다.</p><li><p>재귀를 사용해 <code class="language-plaintext highlighter-rouge">sumTo(100000)</code>를 계산할 수 있을까?</p><p>자바스크립트 엔진은 최대 재귀 깊이를 지원한다. 만개 정도까지는 기본적으로 지원하지만, 대다수의 엔진이 십만까지는 지원하지 않는다. 이 제한을 완화하기 위해 <code class="language-plaintext highlighter-rouge">tail calls optimization</code>라는 최적화를 수행하긴 하지만, 모든 곳에 적용되는 것은 아니고 간단한 경우메나 적용된다.</p></ul><blockquote><p>답: 등차수열이 가장 빠르다. <code class="language-plaintext highlighter-rouge">n</code>에 관계 없이 오직 세 개의 연산만 수행하면 되기 때문이다. 반복을 사용하는 방법은 두 번째로 빠르다. 재귀를 사용하는 방법은 중첩 호출과 실행 스택 관리가 추가로 필요하기 때문에 더 많은 자원을 소비한다. 따라서 속도가 느리다.</p><p>몇몇 자바스크립트 엔진은 ‘tail call’ 최적화를 지원한다. <code class="language-plaintext highlighter-rouge">sumTo</code>처럼 함수가 가장 마지막으로 수행하는 연산이 재귀 호출이라면 <strong>외부 함수는 실행을 다시 시작할 필요가 없기</strong> 때문에 <strong>엔진은 실행 컨텍스트를 기억할 필요가 없다.</strong> 메모리 부담이 사라지는 것이다. 그렇기 때문에 <code class="language-plaintext highlighter-rouge">sumTo(100000)</code>같은 계산이 가능하다. 그런데 자바스크립트 엔진이 tail call 최적화를 지원하지 않는다면(대부분의 엔진이 이를 지원하지 않는다) 엔진에 설정된 스택 사이즈 제한을 넘었기 때문에 최대 스택 사이즈 초과 에러가 발생한다.</p><p>= Q. 질문</p></blockquote><p><strong>2. 팩토리얼 계산하기</strong></p><p>재귀를 사용하여 <code class="language-plaintext highlighter-rouge">n!</code>을 계산하는 함수, <code class="language-plaintext highlighter-rouge">factorial(n)</code> 만들어 보시오.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>피보나치 수 계산하기</strong></p><p>피보나치 수는 첫째와 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열로, <code class="language-plaintext highlighter-rouge">Fn = Fn-1 + Fn-2</code>라는 공식으로 표현할 수 있다.</p><p>처음 두 항은 1이고, 그 다음 항들은 2(1+1), 3(1+2), 5(2+3)이므로 전체 수열은 1, 1, 2, 3, 5, 8, 13, 21…의 형태를 띈다. n 번째 피보나치 수를 반환하는 함수 <code class="language-plaintext highlighter-rouge">fib(n)</code>을 작성하라.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> 
  <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>위와 같이 구현하였더니 연산 시간이 너무 오래 걸렸다.</p><p>해답에 의하면 <code class="language-plaintext highlighter-rouge">fib(77)</code>을 호출했을 때 CPU 리소스를 다 잡아먹어서 잠시 엔진이 멈출 수도 있다고 한다. 연산이 느려지는 이유는 함수 호출 중에 수많은 서브 호출이 일어나기 때문이다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nx">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="nx">fib</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">fib</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="nx">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="nx">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">fib(3)</code>은 <code class="language-plaintext highlighter-rouge">fib(5)</code>와 <code class="language-plaintext highlighter-rouge">fib(4)</code>를 계산할 때 모두 필요하다. 그러므로 <code class="language-plaintext highlighter-rouge">fib(3)</code>은 완전히 다른 두 곳에서 독립적으로 호출되고 평가된다.</p><p><img width="637" alt="Screen Shot 2021-03-28 at 5 50 21 PM" src="https://user-images.githubusercontent.com/50407047/112747983-e6fb8400-8ff3-11eb-91e2-2e2b2255ed27.png" /></p><p>그림을 보면 <code class="language-plaintext highlighter-rouge">fib(2)</code>는 세 번이나 평가된다.</p><p>이런 단점은 <strong>이미 평가된 값을 어딘가에 저장해놓는 식으로 최적화할 수 있다.</strong> <code class="language-plaintext highlighter-rouge">fib(3)</code> 계산이 끝나면 이 겨로가를 어딘가에 저장해놓았다가 같은 값이 필요할 때 저장된 값을 불러오는 식이다.</p><p>또는 재귀가 아닌 반복문을 기반으로 알고리즘을 짤 수 있다. 1과 2로 시작하는 반복문으로 fib(3)을 구하고, 이를 기반으로 fib(4)를 구하고, 이를 기반으로 fib(5)를 구하는 식으로 알고리즘을 구현할 수 있다. 이렇게 구현하면 <strong>이전 두 항의 값만 저장하면 된다.</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이런 접근 방법을 bottom-up 다이나믹 프로그래밍(dynamic programming, 동적 계획법)이라고 부른다.</p><blockquote><p>dynamic programming(기억하기 프로그래밍): <strong>메모이제이션</strong>은 재귀 호출 시, 반복적으로 계산되는 것들의 계산 횟수를 줄이기 위해 이전에 계산했던 값을 저장해두었다가 나중에 재사용하는 방법이다. 메모이제이션이 동적 프로그램 중에 하나이다.</p><p>알고리즘을 짤 때 <strong>분할정복 기법</strong>은 큰 문제를 한 번에 해결하기 힘들 때 작은 여러 개의 문제로 나누어서 푸는 기법이다. 작은 문제를 풀다보면 같은 문제들을 반복해서 푸는 경우가 생긴다. 그 문제들을 매번 재계산하지 않고 값을 저장해두었다가 재사용하는 기법이 동적 프로그래밍이다.</p><p>출처: https://www.zerocho.com/category/Algorithm/post/584b979a580277001862f182</p></blockquote><p><strong>3. 단일 연결 리스트 출력하기</strong></p><p>리스트 내 항목을 차례대로 하나씩 출력해주는 함수 <code class="language-plaintext highlighter-rouge">printList(list)</code>를 반복과 재귀를 사용한 답안을 각각 만들어보자. 그리고 어떤 것이 좋은 코드인지 생각해보자.</p><p>재귀</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">printList</span> <span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">printList</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>반복</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">printList</span> <span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">list</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*while(list)*/</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">list</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>=&gt; 나는 list를 바로 사용했는데, 해답에서는 tmp 변수에 저장하였다. 나처럼 하면 함수를 확장할 때 list를 가지고 뭔가를 할 때 문제가 생길 것이다. 또한 좋은 변수명이 무엇인가를 생각해 봤을 때도 리스트를 임시 변수 <code class="language-plaintext highlighter-rouge">tmp</code>에 저장하는 것이 좋다. <code class="language-plaintext highlighter-rouge">list</code>에는 리스트 그 자체가 저장되어 있는 것이 좋다.</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">printList</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">list</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">tmp</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>반복문을 사용하면 중첩 함수를 호출하는 데 추가적인 리소스를 사용하지 않아, 리소스를 좀 더 효율적으로 사용한다. 반면 재귀를 사용한 방법은 코드 길이가 짧고 이해하기가 쉽다는 장점이 있다.</p><p><strong>단일 연결 리스트를 역순으로 출력하기</strong></p><p>반복</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">printListDesc</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">list</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">tmp</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>재귀</p><p>내가 푼 방법</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">printListDesc</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">list</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">printListDesc</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>해답</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">printListDesc</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">printListDesc</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">printListDesc</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/javascript/'>JavaScript</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/javascript/" class="post-tag no-text-decoration" >JavaScript</a> <a href="/tags/modernjs/" class="post-tag no-text-decoration" >modernJS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=모던 자바스크립트 #6.1 재귀와 스택 - 하연&url=https://hayeon17kim.github.io//posts/modern-js-0601/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=모던 자바스크립트 #6.1 재귀와 스택 - 하연&u=https://hayeon17kim.github.io//posts/modern-js-0601/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=모던 자바스크립트 #6.1 재귀와 스택 - 하연&url=https://hayeon17kim.github.io//posts/modern-js-0601/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/system-deisign-capacity-estimation/">System Design: Capacity Estimate</a><li><a href="/posts/today-i-learned-2021-04-27/">주니어 성장일기: 2021.04.27</a><li><a href="/posts/today-i-learned-2021-04-26/">주니어 성장일기: 2021.04.26</a><li><a href="/posts/fastcampus-01/">자료구조와 알고리즘이란</a><li><a href="/posts/today-i-learned-2021-04-25/">주니어 성장일기: 2021.04.25</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/bitcamp/">bitcamp</a> <a class="post-tag" href="/tags/modernjs/">modernJS</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/trouble-shooting/">trouble-shooting</a> <a class="post-tag" href="/tags/devil/">devil</a> <a class="post-tag" href="/tags/corejs/">corejs</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/modern-js-0201/"><div class="card-body"> <span class="timeago small" > Jan 4 <i class="unloaded">2021-01-04T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>모던 자바스크립트 #2.1. Hello, world!</h3><div class="text-muted small"><p> 모던 JavaScript 튜토리얼을 따라가면서 정리합니다. 2.1. Hello, world! Node.js와 같은 서버 사이드 환경에서 스크립트를 실행하고 싶다면 node my.js와 같은 명령어를 사용하면 된다. script 태그 script 태그를 이용하면 자바스크립트 프로그램을 HTML 문서 어느 곳에나 삽입할 수 있다. 브라우저는 이 태...</p></div></div></a></div><div class="card"> <a href="/posts/modern-js-0202/"><div class="card-body"> <span class="timeago small" > Jan 4 <i class="unloaded">2021-01-04T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>모던 자바스크립트 #2.2. 코드 구조</h3><div class="text-muted small"><p> 모던 JavaScript 튜토리얼을 따라가면서 정리합니다. 2.2. 코드 구조 statement 문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미한다. 세미콜론 줄바꿈이 있다면 세미콜론을 생랴가할 수 있다. 자바스크립트는 줄바꿈이 있으면 이를 ‘암시적’ 세미콜론으로 해석한...</p></div></div></a></div><div class="card"> <a href="/posts/modern-js-0203/"><div class="card-body"> <span class="timeago small" > Jan 5 <i class="unloaded">2021-01-05T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>모던 자바스크립트 #2.3. 엄격 모드</h3><div class="text-muted small"><p> 모던 JavaScript 튜토리얼을 따라가면서 정리합니다. 2.3. 엄격 모드 ECMAScript5(ES5)가 등장하기 전인 2009년까지는 기존 기능 변경 없이 새로운 기능이 추가되었다. 새롭게 정의된 ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있으므로 변경사항...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/programmers-survival-kit-02/" class="btn btn-outline-primary" prompt="Older"><p>정렬(Sort): 가장 큰 수</p></a> <a href="/posts/programmers-survival-kit-03/" class="btn btn-outline-primary" prompt="Newer"><p>이분탐색(Binary Search): 예산</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Loading comments from <a href="https://disqus.com/">Disqus</a> ...</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//hayeon17kim-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = '모던 자바스크립트 #6.1 재귀와 스택'; this.page.url = 'https://hayeon17kim.github.io//posts/modern-js-0601/'; this.page.identifier = '/posts/modern-js-0601/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/MONI56219559">hayeon_kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/bitcamp/">bitcamp</a> <a class="post-tag" href="/tags/modernjs/">modernJS</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/trouble-shooting/">trouble shooting</a> <a class="post-tag" href="/tags/devil/">devil</a> <a class="post-tag" href="/tags/corejs/">corejs</a> <a class="post-tag" href="/tags/network/">network</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://hayeon17kim.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
