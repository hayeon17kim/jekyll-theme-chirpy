<!DOCTYPE html><html lang="kr-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content=":book: 자바의 정석 #9.1: java.lang 패키지" /><meta name="author" content="hayeon_kim" /><meta property="og:locale" content="kr_KR" /><meta name="description" content="java.lang 패키지" /><meta property="og:description" content="java.lang 패키지" /><link rel="canonical" href="https://hayeon17kim.github.io//posts/textbook-0901/" /><meta property="og:url" content="https://hayeon17kim.github.io//posts/textbook-0901/" /><meta property="og:site_name" content="하연" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-02T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content=":book: 자바의 정석 #9.1: java.lang 패키지" /><meta name="twitter:site" content="@MONI56219559" /><meta name="twitter:creator" content="@hayeon_kim" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"hayeon_kim"},"headline":":book: 자바의 정석 #9.1: java.lang 패키지","dateModified":"2020-10-02T00:00:00+08:00","datePublished":"2020-10-02T00:00:00+08:00","description":"java.lang 패키지","url":"https://hayeon17kim.github.io//posts/textbook-0901/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hayeon17kim.github.io//posts/textbook-0901/"},"@context":"https://schema.org"}</script><title>:book: 자바의 정석 #9.1: java.lang 패키지 | 하연</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-173202420-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-173202420-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/bio-photo.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">하연</a></div><div class="site-subtitle font-italic">어제보다 나은 코드를 위해</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-laptop-code ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/hayeon17kim" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/MONI56219559" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hayeon17kim','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>:book: 자바의 정석 #9.1: java.lang 패키지</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>:book: 자바의 정석 #9.1: java.lang 패키지</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Oct 2, 2020, 12:00 AM +0800" > Oct 2, 2020 <i class="unloaded">2020-10-02T00:00:00+08:00</i> </span> by <span class="author"> hayeon_kim </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5046 words">28 min</span></div></div><div class="post-content"><h1 id="javalang-패키지">java.lang 패키지</h1><h2 id="object-클래스">Object 클래스</h2><p>멤버변수는 없고 오직 11개의 메서드만 가지고 있다.</p><h3 id="메서드">메서드</h3><ul><li><code class="language-plaintext highlighter-rouge">protected Object clone()</code><li><code class="language-plaintext highlighter-rouge">public boolean equals(Object ob)</code><li><code class="language-plaintext highlighter-rouge">protected void finalize()</code>: 객체가 소멸될 때 가비지 컬렉터에 의해 자동으로 호출된다. 이 때 수행되어야 하는 코드가 있을 때 오버라이딩한다. (거의 사용 안함)<li><code class="language-plaintext highlighter-rouge">public Class getClass()</code>: 객체 자신의 클래스 정보를 담고 있는 Class 인스턴스 반환<li><code class="language-plaintext highlighter-rouge">public int hashCode()</code><li><code class="language-plaintext highlighter-rouge">public String toString()</code>: 객체 정보를 문자열로 반환<li><code class="language-plaintext highlighter-rouge">notify()</code>: 객체 자신을 사용하려고 기다리는 스레드를 하나만 깨운다.<li><code class="language-plaintext highlighter-rouge">notifyAll()</code>: 객체 자신을 사용하려고 기다니는 모든 스레드를 깨운다.<li><code class="language-plaintext highlighter-rouge">wait()</code>: notify()나 notifyAll()을 호출할 때까지 현재 스레드를 또는 무한히 혹은 지정된 시간동안 기다리게 한다.</ul><h3 id="equals">equals()</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 실제 소스코드</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>두 객체의 같고 다름을 참조변수의 값으로 판단한다. 객체를 생성할 때 메모리의 비어있는 공간을 찾아 생성하므로 서로 다른 두 개의 객체가 같은 주소를 갖는 일은 없다.</p><p>객체의 주소가 아니라 값을 비교하도록 만드려면 Object의 equals()를 오버라이딩해야 한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Person</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">id</span> <span class="o">==</span> <span class="o">((</span><span class="nc">Person</span><span class="o">)</span><span class="n">obj</span><span class="o">).</span><span class="na">id</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>String 클래스 역시 Object 클래스의 equals메서드를 그대로 사용하는 것이 아니라 오버라이딩을 통해서 String 인스턴스가 갖는 문자열 값을 비교하도록 되어 있다. 따라서 문자열의 내용이 같으면 true 값을 얻는다. <strong>String 클래스뿐만 아니라 Date, File, wrapper 클래스</strong>도 equals()가 오버라이딩 되어 있다. 그러나 StringBuffer 클래스는 오버라이딩 되어 있지 않다.</p><h3 id="hashcode">hashCode()</h3><p>이 메서드는 해싱 기법에 사용되는 해시 함수를 구현한 것이다. 해싱은 데이터 관리기법 중에 하나인데 다량의 데이터를 저장하고 검색하는 데 유용하다. 해시함수는 찾고자 하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환한다.</p><p>Object 클래스에 정의된 hashCode메서드는 객체의 주소값을 ㅣㅇ용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 같은 해시코드를 가질 수 없다.</p><p>객체의 같고 다름을 판단해야 하는 경우라면 equals 메서드뿐 아니라 hashCode 메서드도 적절히 오버라이딩해야 한다. 특히 <strong>해싱기법을 사용하는 HashMap이나 HashSet과 같은 클래스에 저장할 객체라면 반드시 hashCode 메서드를 오버라이딩해야 한다.</strong></p><p>String 클래스는 문자열의 내용이 같으면 동일한 해시코드를 반환하도록 이 메서드를 오버라이딩하였다. 반면 System.identityHashCode(Object x)는 Object 클래스처럼 객체의 주소값으로 해시코드를 생성하기에 모든 객체에 대해 항상 다른 해시코드 값을 반환할 것을 보장한다.</p><h3 id="tostring">toString()</h3><p>이 메서드는 인스턴스에 대한 정보를 문자열(String)로 제공할 목적으로 정의한 것이다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">//Object 클래스에 정의된 toString()</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"@"</span> <span class="o">+</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toHexString</span><span class="o">(</span><span class="n">hashCode</span><span class="o">());</span>
<span class="o">}</span>
</pre></table></code></div></div><p>String 클래스는 toString()이 String 인스턴스가 갖고 있는 문자열을 반환하도록 오버라이딩 되어 있고, Date 클래스는 Date 인스턴스가 갖고 있는 날짜와 시간을 문자열로 변환하여 반환하도록 오버라이딩 되어 있다. 이처럼 toString()은 일반적으로 인스턴스나 클래스에 대한 정보 또는 인스턴스 변수들의 값을 문자열로 변환하여 반환하도록 오버라이딩되는 것이 보통이다.</p><blockquote><p>조상에서 정의된 메서드를 자손에서 오버라이딩할 때는 조상에 정의된 접근범위보다 같거나 더 넓어야 한다.</p></blockquote><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="s">"kind: "</span> <span class="o">+</span> <span class="n">kind</span> <span class="o">+</span> <span class="s">", number: "</span> <span class="o">+</span> <span class="n">number</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="clone">clone()</h3><p>자신을 복제하여 새로운 인스턴스를 생성하는 일을 한다. 어떤 인스턴스에 대해 작업을 할 때 clone()을 이용해서 새로운 인스턴스를 생성해서 작업을 하면 <strong>작업이전의 값이 보존</strong>되므로 작업에 실패해서 원래의 상태로 되돌리거나 변<strong>경되기 전의 값을 참고</strong>하는 데 도움이 된다.</p><p>Object 클래스에 정의된 clone()은 인스턴스변수의 값만을 복사하기 때문에 참조변수 타입의 인스턴스 변수가 정의되어 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다. 이런 경우 clone() 메서드를 오버라이딩해야 한다.</p><p>Cloneable 인터페이스를 구현한 클래스에서만 clone()을 호출할 수 있다. 이 인터페이스를 구현하지 않고 clone()을 호출하면 예외가 발생한다.</p><p>clone() 사용 방법</p><ul><li>복제할 클래스가 Cloneable 인터페이스를 구현해야 한다.<ul><li>클래스 작성자가 복제를 허용한다는 의미이다.</ul><li>clone()을 오버라이딩하면서 접근제어자를 protected에서 public으로 변경한다.<li>조상 클래스의 clone()을 호출하는 코드가 포함된 try catch 문을 작성한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Point</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>
  <span class="c1">//..</span>
  <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">obj</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">CloneNotSupportedExcepton</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>배열을 복사할 때는 arraycopy 메서드를 사용해도 된다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arrClone</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>

<span class="kt">int</span><span class="o">[]</span> <span class="n">arrClone2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
<span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arrClone2</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</pre></table></code></div></div><p>배열뿐만 아니라 Vecter, ArrayList, LinkedList, HAshSet, TreeSet, HashMap, TreeMap, Calendar, Date과 같은 클래스들이 이와 같은 방식으로 복제가 가능하다. clone()으로 복제가 가능한 클래스인지 확인하려면 Cloneable을 구현했는지 확인하면 된다.</p><h4 id="공변-반환타입covariant-return-type">공변 반환타입(covariant return type)</h4><p>오버라이딩할 때 조상 메서드의 반환타입을 자손 클래스의 타입으로 변경을 허용</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">CloneNotSupportedExcepton</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
  <span class="k">return</span> <span class="o">(</span><span class="nc">Point</span><span class="o">)</span><span class="n">obj</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>공변 반환타입을 사용하면 번거로운 형변환이 줄어든다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// Point copy = (Point)original.clone();</span>
<span class="nc">Point</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</pre></table></code></div></div><h4 id="얕은-복사와-같은-복사">얕은 복사와 같은 복사</h4><p>원본이 참조하고 있는 객체까지 복제하는 것을 깊은 복사라고 한다. 깊은 복사에서는 원본과 복사본이 서로 다른 객체를 참조하기 때문에 원본의 변경이 복사본에 영향을 미치지 않는다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>
  <span class="nc">Point</span> <span class="n">p</span><span class="o">;</span>
  <span class="kt">double</span> <span class="n">r</span><span class="o">;</span>
  <span class="nc">Circle</span> <span class="o">(</span><span class="nc">Point</span> <span class="n">p</span><span class="o">,</span> <span class="kt">double</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
  <span class="o">}</span>
  
    
  <span class="c1">//깊은 복사</span>
  <span class="kd">public</span> <span class="nc">Circle</span> <span class="nf">shallowCopy</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">obj</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">Circle</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
  <span class="o">}</span>
    
  
  <span class="c1">//깊은 복사</span>
  <span class="kd">public</span> <span class="nc">Circle</span> <span class="nf">deepCopy</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">obj</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="nc">Circle</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Circle</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
    
    <span class="c1">// 복제한 객체가 새로운 Point 인스턴스를 참조하도록 했다.</span>
    <span class="n">c</span><span class="o">.</span><span class="na">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">p</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">p</span><span class="o">.</span><span class="na">y</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
  <span class="nc">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="getclass">getClass()</h3><p>자신이 속한 클래스의 Class 객체를 반환하는 메서드이다.</p><p><strong>Class 객체는 클래스의 모든 정보를 담고 있으며, 클래스당 단 1개만 존재한다. 클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때, 자동으로 생성된다.</strong> <strong>클래스 로더</strong>는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다. 먼저 기존에 생성된 클래스 객체가 메모리에 존재하는 지 확인하고 있으면 <strong>객체의 참조를 반환</strong>하고 없으면 클래스 패스에 지정된 경로를 따라서 클래스 파일을 읽는다. 못 찾으면 ClassNotFoundException이 발생하고, <strong>찾으면 해당 클래스 파일을 일거서 Class 객체로 반환</strong>한다.</p><p>즉 파일 형태로 저장되어 있는 클래스를 읽어서 Class 클래스에 정의된 형식으로 변환하는 것이다. <strong>클래스 파일을 읽어서 사용하기 편한 형태로 저장해 놓은 것이 클래스 객</strong>체이다.</p><h4 id="class-객체를-얻는-방법">Class 객체를 얻는 방법</h4><p>클래스의 정보가 필요할 때 먼저 Class에 대한 참조를 얻어 와야 하는데, 해당 Class 객체에 대한 참조를 얻는 방법은 여러 가지가 있다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Class</span> <span class="n">cObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Card</span><span class="o">().</span><span class="na">getClass</span><span class="o">();</span> <span class="c1">// 생성된 객체로부터 얻는 방법</span>
<span class="nc">Class</span> <span class="n">cObj</span> <span class="o">=</span> <span class="nc">Card</span><span class="o">.</span><span class="na">class</span><span class="o">;</span> <span class="c1">// 클래스 리터럴(*.class)로부터 얻는 방법</span>
<span class="nc">Class</span> <span class="n">cObj</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"Card"</span><span class="o">);</span> <span class="c1">// 클래스 이름으로부터 얻는 방법</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">forName()</code>은 특정 클래스 파일(예: 데이터베이스 드라이버)을 메모리에 올릴 때 주로 사용한다.</p><p>Class 객체를 이용하면 클래스에 정의된 멤버 이름이나 개수 등 클래스에 대한 모든 정보를 얻을 수 있기 때문에 Class 객체를 통해서 객체를 생성하고 호출하는 등 보다 동적인 코드를 작성할 수 있다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">Card</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Card</span><span class="o">();</span> <span class="c1">// new 연산자를 이용해 객체 생성</span>
<span class="nc">Card</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Card</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span> <span class="c1">// Class 객체를 이용해서 객체 생성</span>
</pre></table></code></div></div><h1 id="string-클래스">String 클래스</h1><h2 id="변경-불가능한immutable-클래스">변경 불가능한(immutable) 클래스</h2><p>한 번 생성된 String 인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없다. 덧셈 연산자를 사용해서 문자열을 결합하는 것은 매 연산 시마다 새로운 문자열을 가진 String 인스턴스가 생성되어 메모리 공간을 차지하게 된다. 대신 결합이나 추출 등 문자열을 다루는 작업이 많을 경우 StringBuffer클래스를 사용하는 것이 좋다. StringBuffer인스턴스에 저장된 문자열은 변경이 가능하다.</p><h2 id="문자열의-비교">문자열의 비교</h2><ul><li>문자열 리터럴을 지정하는 방법: 이미 존재하는 것을 재사용<ul><li>문자열 리터럴은 클래스가 메모리에 로드될 때 자동적으로 미리 생성된다.</ul><li>String 클래스의 생성자를 사용해서 만드는 방법: new 연산자에 의해 메모리 할당이 이루어지기 때문에 항상 새로운 String 인스턴스 생성</ul><h2 id="문자열-리터럴">문자열 리터럴</h2><p>자바 소스파일에 포함된 모든 <strong>문자열 리터럴은 컴파일 시 클래스 파일에 저장</strong>된다. 이때 같은 내용의 <strong>문자열 리터럴은 한 번만 저장된다. 한 번 생성하면 내용을 변경할 수 없기 때문에 하나의 인스턴스를 공유하면 되기 때문이다</strong>. 클래스 파일에는 소스파일에 포함된 모든 리터럴의 목록이 있다. 해당 클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때, 이 리터럴의 목록에 있는 리터럴들이 자동적으로 생성되어 JVM내에 있는 상수풀에 저장된다.</p><h2 id="빈-문자열">빈 문자열</h2><p>빈배열이 가능한데, char형 빈배열을 내부적으로 가지고 있는 문자열이 빈 문자열이다. String을 초기화할 때는 보통 null보다는 빈문자열로 초기화한다.</p><h2 id="자주-사용하는-메서드">자주 사용하는 메서드</h2><ul><li><code class="language-plaintext highlighter-rouge">String(char[] value)</code><li><code class="language-plaintext highlighter-rouge">String(StringBuffer buf)</code><li><code class="language-plaintext highlighter-rouge">char charAt(int index)</code><li><code class="language-plaintext highlighter-rouge">int compareTo(String str)</code>: 0, 1, -1 리턴<li><code class="language-plaintext highlighter-rouge">boolean contains(CharSequence s)</code>: 지정된 문자열이 포함되었는지 검사<li><code class="language-plaintext highlighter-rouge">boolean endsWith(String suffix)</code><li><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code><li><code class="language-plaintext highlighter-rouge">int indexOf(int ch)</code>, <code class="language-plaintext highlighter-rouge">indexOf(int ch, int pos)</code>. <code class="language-plaintext highlighter-rouge">indexOf(String str)</code><li><code class="language-plaintext highlighter-rouge">String intern()</code>: 문자열을 상수풀에 등록한다. 이미 상수풀에 같은 내용의 문자열이 있을 경우 그 문자열의 주소값을 반환한다.<li><code class="language-plaintext highlighter-rouge">String replace(old, nw)</code>: 문자열 중 문자열을 새로운 문자열로 바꾼 문자열을 반환한다. (문자, 문자열 리터럴, String 모두 파라미터로 올 수 잇음)<li><code class="language-plaintext highlighter-rouge">String replaceAll(old, nw)</code>: 일치하는 것을 모두 변경<li><code class="language-plaintext highlighter-rouge">String[] split(String regex)</code>: 문자열을 지정된 분리자로 나누어 문자열 배열에 담아 반환한다.<li><code class="language-plaintext highlighter-rouge">boolean startsWith(String prefix)</code><li><code class="language-plaintext highlighter-rouge">String substring(int begin), (int begin, itn end)</code>: 시작 위치부터 끝 위치에 포함된 문자열을 얻는다. 이 때, 시작범위의 문자는 범위에 포함되지만, 끝 위치의 문자는 포함되지 않는다. (begin &lt;= x &lt; end)<li><code class="language-plaintext highlighter-rouge">String toLowerCase()</code><li><code class="language-plaintext highlighter-rouge">String toUpperCase()</code><li><code class="language-plaintext highlighter-rouge">String toString()</code>: String 인스턴스에 저장되어 있는 문자열을 반환한다.<li><code class="language-plaintext highlighter-rouge">String trim()</code>: 문자열의 왼쪽 끝과 오른쪽 끝에 있는 공백을 없앤 결과를 반환한다. 이 때 문자열 중간에 잇는 공백은 제거되지 않는다.<li><code class="language-plaintext highlighter-rouge">static String valueOf(원시타입 + Object 객체)</code>: 지정된 값을 문자열로 변환하여 반환한다. 참조변수의 경우, toString()을 호출한 결과를 반환한다.</ul><blockquote><p>CharSequence: 인터페이스로 String, StringBuffer 등의 클래스가 구현하였다.</p></blockquote><h3 id="join과-stringjoiner">join()과 StringJoiner</h3><p>join()은 여러 문자열 사이에 구분자를 넣어서 결합한다. split()과 반대의 작업을 한다고 생각하자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">animals</span> <span class="o">=</span> <span class="s">"dog,cat,bear"</span><span class="o">;</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">animals</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="n">arr</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span> <span class="c1">//dog-cat-bear</span>
</pre></table></code></div></div><p>java.util.StringJoiner 클래스를 사용할 수도 있다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nc">StringJoiner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringJoiner</span> <span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="s">"["</span><span class="o">,</span> <span class="s">"]"</span><span class="o">);</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">str</span> <span class="o">=</span> <span class="o">{</span><span class="s">"aaa"</span><span class="o">,</span> <span class="s">"bbb"</span><span class="o">,</span> <span class="s">"ccc"</span><span class="o">};</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strArr</span><span class="o">)</span>
  <span class="n">sj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sj</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> <span class="c1">//[AAA, BBB, CCC]</span>
</pre></table></code></div></div><h3 id="유니코드의-보충문자">유니코드의 보충문자</h3><p>String 클래스의 메서드 중 메서드 타입이 int인 것들도 있다. 이는 확장된 유니코드를 다루기 위해서이다. 유니코드는 원래 2바이트(16비트) 문자체계인데 이것도 모자라서 20비트로 확장하게 되었다. 그래서 하나의 문자를 char 타입으로 다루지 못하고 int 타입으로 다룰 수밖에 없다. 이렇게 확장에 의해 추가된 문자들을 보충 문자(supplementary characters)라고 한다.</p><h3 id="문자-인코딩-변환">문자 인코딩 변환</h3><p>getBytes(String charsetName)를 사용하면, 문자열의 문자 인코딩을 다른 인코딩으로 변경할 수 있다.</p><blockquote><p>사용 가능한 문자인코딩의 목록은 <code class="language-plaintext highlighter-rouge">System.out.println(java.nio.charset.Charset.availableCharsets())</code>로 출력할 수 있다.</p></blockquote><h3 id="stringformat">String.format()</h3><p>형식화된 문자열을 만들어내는 메서드</p><h3 id="기본형-값을-string으로-변환">기본형 값을 String으로 변환</h3><ul><li><p>String.valueOf() 메서드를 사용한다. =&gt; 성능이 더 좋다.</p><li><p>빈 문자열을 더한다. =&gt; 더 간단하다.</p></ul><h3 id="string을-기본형-값으로-변환">String을 기본형 값으로 변환</h3><ul><li>Integer.valueOf(String s): Integer 객체 반환<li>Integer.parseInt(String s): int값 반환</ul><p>두 메서드는 반환 타입만 다를 뿐 같은 역할을 한다. <strong><code class="language-plaintext highlighter-rouge">valueOf</code>는 <code class="language-plaintext highlighter-rouge">parseInt</code> 이후에 메서드 이름을 통일하기 위해 추가된 메서드이다.</strong></p><blockquote><p>문자열 “A”를 문자 ‘A’로 변환하려면 char ch = “A”.charAt(0);과 같이 하면 된다.</p></blockquote><p>parseInt()나 parseFloat()같은 메서드는 문자열에 공백 또는 문자가 포함되어 있는 경우 변환 시 예외가 발생할 수 있으므로 주의해야 한다. 그래서 문자열 양끝에 공백을 제거해주는 trim()을 습관적으로 같이 사용하기도 한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="s">" 123 "</span><span class="o">.</span><span class="na">trim</span><span class="o">());</span>
</pre></table></code></div></div><p>그러나 부호를 의미하는 ‘+’나 소수점을 의미하는 ‘.’, float형 값을 뜻하는 ‘f’와 같은 자료형 접미사는 자료형에 알맞는 변환을 할 경우에만 허용된다.</p><p>문자열을 숫자로 변환하는 과정에서는 예외가 발생하기 쉽기 때문에 주의를 기울이자.</p><h2 id="stringbuffer">StringBuffer</h2><p>String 클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 StringBuffer 클래스는 변경이 가능하다. 내부적으로 문자열 편집을 위한 버퍼(buffer)를 가지고 있으며, StringBuffer 인스턴스를 생성할 때 그 크기를 지정할 수 있다. 지정하지 않으면 16개의 문자를 저장할 수 있는 크기의 버퍼를 생성한다. 작업하려는 문자가 배열의 길이보다 작을 때는 내부적으로 버퍼의 크기를 증가시키는 작업이 수행된다. 배열의 길이는 변경될 수 없으므로 새로운 길이의 배열을 생성한 후에 이전 배열의 값을 복사해야 한다. 이러면 인스턴스 char[] 변수는 길이가 증가된 새로운 배열을 참조하게 된다.</p><p>append()의 반환타입은 StringBuffer인데, 자신의 주소를 반환한다. 따라서 연속적으로 append를 호출할 수 있다. (<code class="language-plaintext highlighter-rouge">sb.append("123").append("123")</code>)</p><p>StringBuffer는 equals를 오버라이딩하지 않아 StringBuffer 객체로 equals()를 호출하면 등가비교연산자로 비교한 것과 같다. 반면 toString()은 오버라이딩되어 있다. 따라서 StringBuffer 인스턴스에 담긴 문자열을 비교하기 위해서는 <code class="language-plaintext highlighter-rouge">toString()</code>을 호출해서 String 인스턴스를 얻은 다음, 여기에 equals 메서드를 사용해서 비교해야 한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sb2</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s2</span><span class="o">));</span>
</pre></table></code></div></div><p>StringBuffer 클래스 역시 문자열을 다루기 위한 것이기 때문에 String 클래스와 유사한 메서드를 가지고 있다. 추가, 변경, 삭제와 같이 저장된 내용을 변경할 수 있는 메서드들이 추가로 제공된다.</p><ul><li>StringBuffer(): 16문자를 담을 수 있는 버퍼를 가진 인스턴스 생성<li>StringBuffer(int length)<li>StringBuffer(String str)<li><p>StringBuffer append(원시타입 / char[] / Object / String )</p><li>int capacity(): <strong>버퍼크기</strong>를 알려준다.<li>int length(): <strong>버퍼에 담긴 문자열의 길이</strong>를 알려준다.<li>char charAt()<li>StringBuffer delete(int start, int end)<li>StringBuffer deleteCharAt(int index)<li><p>StringBuffer insert(int pos,원시타입/char[]/Object/String): 매개변수로 받은 값을 문자열로 변환하여 지정된 위치(pos)에 추가</p><li><p>StringBuffer replace(int start, int end, String str)</p><li>StringBuffer reverse(): 문자열의 순서를 거꾸로 나열한다.<li>void setCharAt(int index, char ch): 지정된 위치의 문자를 주어진 문자로 바꾼다.<li>void setLength(int newLength): 문자열의 길이를 변경한다. 길이를 늘리는 경우 나머지 빈 공간을 널문자 ‘\u0000’로 채운다.<li>String toString()<li>String subString(int start), (int start, int end)</ul><h2 id="stringbuilder">StringBuilder</h2><p>StringBuffer는 멀티스레드에 안전(thread safe)하도록 동기화되어있다. 그러나 멀티스레드로 작성된 프로그램이 아닌 경우, StringBuffer의 동기화는 불필요하게 성능만 떨어뜨리게 된다. 따라서 StringBuffer에서 스레드의 동기화만 뺀 StringBuilder가 새로 추가되었다. StringBuilder는 StringBuffer와 완전히 똑같은 기능으로 작성되어있어서 교체가 쉽다. 즉 StringBuffer타입의 레퍼런스와 생성자만 바꾸면 된다는 말이다.</p><p>하지만 성능향상이 반드시 필요한 경우를 제외하고는 기존에 작성한 코드에서 StringBuffer를 STringBuilder로 굳이 바꿀 필요는 없다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/textbook/'>textbook</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/textbook/" class="post-tag no-text-decoration" >textbook</a> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=:book: 자바의 정석 #9.1: java.lang 패키지 - 하연&url=https://hayeon17kim.github.io//posts/textbook-0901/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=:book: 자바의 정석 #9.1: java.lang 패키지 - 하연&u=https://hayeon17kim.github.io//posts/textbook-0901/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=:book: 자바의 정석 #9.1: java.lang 패키지 - 하연&url=https://hayeon17kim.github.io//posts/textbook-0901/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/system-deisign-capacity-estimation/">System Design: Capacity Estimate</a><li><a href="/posts/today-i-learned-2021-04-27/">주니어 성장일기: 2021.04.27</a><li><a href="/posts/today-i-learned-2021-04-26/">주니어 성장일기: 2021.04.26</a><li><a href="/posts/fastcampus-01/">자료구조와 알고리즘이란</a><li><a href="/posts/today-i-learned-2021-04-25/">주니어 성장일기: 2021.04.25</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/bitcamp/">bitcamp</a> <a class="post-tag" href="/tags/modernjs/">modernJS</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/trouble-shooting/">trouble-shooting</a> <a class="post-tag" href="/tags/devil/">devil</a> <a class="post-tag" href="/tags/corejs/">corejs</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/textbook-0704/"><div class="card-body"> <span class="timeago small" > Sep 3, 2020 <i class="unloaded">2020-09-03T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>:book: 자바의 정석 #7.4: 제어자</h3><div class="text-muted small"><p> 제어자 제어자란? 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 하나의 대상에 대해서 여러 제어자를 조합해서 사용할 수 있다. 단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다. 제어자의 종류 접근 제어자: public, protected, default, private 그 외 제...</p></div></div></a></div><div class="card"> <a href="/posts/textbook-0705/"><div class="card-body"> <span class="timeago small" > Sep 4, 2020 <i class="unloaded">2020-09-04T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>:book: 자바의 정석 #7.5: 다형성</h3><div class="text-muted small"><p> 다형성 다형성이란? 객체지향개념에서 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’을 말한다. 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다. 다시 말해, 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하였다. 참조변수의 타입은 참조할 수...</p></div></div></a></div><div class="card"> <a href="/posts/textbook-0706/"><div class="card-body"> <span class="timeago small" > Sep 5, 2020 <i class="unloaded">2020-09-05T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>:book: 자바의 정석 #7.6: 추상클래스</h3><div class="text-muted small"><p> 추상클래스 추상클래스란? 미완성 메서드를 포함하고 있는 미완성 설계도이다. 추상 클래스로는 인스턴스를 생성할 수 없다. 다만 새로운 클래스를 작성하는 데 있어서 바탕이 되는 조상 클래스로 미가 있다. 추상 클래스는 추상 메서드를 포함하고 있다는 것을 제외하고는 일반 클래스와 다르지 않다. 생성자, 멤버변수, 메서드를 가질 수 있다. 한편 추상 메...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/corejs0211/" class="btn btn-outline-primary" prompt="Older"><p>코어 자바스크립트 #2.11: 논리연산자</p></a> <a href="/posts/corejs0212/" class="btn btn-outline-primary" prompt="Newer"><p>코어 자바스크립트 #2.12: null 병합 연산자 '?'</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Loading comments from <a href="https://disqus.com/">Disqus</a> ...</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//hayeon17kim-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = ':book: 자바의 정석 #9.1: java.lang 패키지'; this.page.url = 'https://hayeon17kim.github.io//posts/textbook-0901/'; this.page.identifier = '/posts/textbook-0901/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/MONI56219559">hayeon_kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/bitcamp/">bitcamp</a> <a class="post-tag" href="/tags/modernjs/">modernJS</a> <a class="post-tag" href="/tags/project/">project</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/trouble-shooting/">trouble shooting</a> <a class="post-tag" href="/tags/devil/">devil</a> <a class="post-tag" href="/tags/corejs/">corejs</a> <a class="post-tag" href="/tags/network/">network</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://hayeon17kim.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
